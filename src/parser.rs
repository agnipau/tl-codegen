use nom::{
    bytes::complete::{is_a, is_not, tag},
    error::ErrorKind,
    multi::{many0, many1},
    IResult,
};

const SPACE: &str = " \t\r\n";
const NEWLINE: &str = "\r\n";

#[derive(Debug, PartialEq, Clone)]
pub(crate) enum LineOutputType {
    Function,
    Type,
}

#[derive(Debug, PartialEq, Clone)]
pub(crate) struct LineOutput {
    pub(crate) type_: LineOutputType,
    pub(crate) value: LineOutputValue,
}

#[derive(Debug, PartialEq, Clone)]
pub(crate) enum LineOutputValue {
    NormalLineOutputValue(NormalLineOutputValue),
    MetadataLineOutputValue(MetadataLineOutputValue),
}

#[derive(Debug, PartialEq, Clone)]
pub(crate) struct MetadataLineOutputValue {
    pub(crate) tokens: Vec<MetadataLineOutputValueToken>,
}

#[derive(Debug, PartialEq, Clone)]
pub(crate) struct MetadataLineOutputValueToken {
    pub(crate) name: String,
    pub(crate) value: String,
}

#[derive(Debug, PartialEq, Clone)]
pub(crate) struct NormalLineOutputValue {
    pub(crate) id: String,
    pub(crate) fields: Vec<NormalLineOutputValueField>,
    pub(crate) name: String,
}

#[derive(Debug, PartialEq, Clone)]
pub(crate) struct NormalLineOutputValueField {
    pub(crate) name: String,
    pub(crate) type_: String,
}

fn parse_metadata_line_token(input: &str) -> IResult<&str, MetadataLineOutputValueToken> {
    let input = match is_a::<_, _, (_, _)>(SPACE)(input) {
        Ok((input, _)) => input,
        Err(_) => input,
    };
    let (input, _) = tag("@")(input)?;
    let (input, name) = is_not(SPACE)(input)?;
    let (input, _) = is_a(SPACE)(input)?;
    let (input, value) = is_not("@")(input)?;
    Ok((
        input,
        MetadataLineOutputValueToken {
            name: name.to_owned(),
            value: value.trim_end().to_owned(),
        },
    ))
}

#[inline]
fn map_err_line_output_type<'a>(
    line_output_type: LineOutputType,
) -> impl FnOnce(nom::Err<(&'a str, ErrorKind)>) -> nom::Err<((&'a str, LineOutputType), ErrorKind)>
{
    |err| match err {
        nom::Err::Error((input, kind)) => nom::Err::Error(((input, line_output_type), kind)),
        _ => unreachable!(),
    }
}

fn parse_metadata_line(
    input: (&str, LineOutputType),
) -> IResult<(&str, LineOutputType), LineOutput> {
    let (input, type_) = input;
    let input = match is_a::<_, _, (_, _)>(NEWLINE)(input) {
        Ok((input, _)) => input,
        Err(_) => input,
    };
    let (input, _) = tag("//")(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, to_newline) =
        is_not(NEWLINE)(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (_, mut tokens) = many1(parse_metadata_line_token)(to_newline)
        .map_err(map_err_line_output_type(type_.clone()))?;
    let mut input = input.trim_start();

    let mut last_token_rest_content = String::new();
    loop {
        // TODO: Make it work even with '//     -', even if not necessary.
        if input.starts_with("//-") {
            let (new_input, _) =
                tag("//-")(input).map_err(map_err_line_output_type(type_.clone()))?;
            let (new_input, to_newline) =
                is_not(NEWLINE)(new_input).map_err(map_err_line_output_type(type_.clone()))?;
            input = new_input.trim_start();
            last_token_rest_content.push_str(&format!(" {}", to_newline));
        } else {
            break;
        }
    }
    if let Some(last_token) = tokens.last_mut() {
        last_token.value.push_str(&last_token_rest_content);
    }

    Ok((
        (input, type_.clone()),
        LineOutput {
            type_,
            value: LineOutputValue::MetadataLineOutputValue(MetadataLineOutputValue { tokens }),
        },
    ))
}

#[test]
fn test_parse_metadata_line() {
    let res = many1(parse_metadata_line)((r##"
//@description Represents a remote file
//@id Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
//-If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
//-If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the client with the HTTP URL in the original_path and "#url#" as the conversion string. Clients should generate the file by downloading it to the specified location
//@unique_id Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
//@is_uploading_active True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
//@is_uploading_completed True, if a remote copy is fully available
//@uploaded_size Size of the remote available part of the file; 0 if unknown
"##.trim_start(), LineOutputType::Type));
    assert_eq!(
        res,
        Ok((
            ("", LineOutputType::Type),
            vec![
                LineOutput {
                    type_: LineOutputType::Type,
                    value: LineOutputValue::MetadataLineOutputValue(
                        MetadataLineOutputValue {
                            tokens: vec![
                                MetadataLineOutputValueToken {
                                    name: "description".to_owned(),
                                    value: "Represents a remote file".to_owned(),
                                },
                            ],
                        },
                    ),
                },
                LineOutput {
                    type_: LineOutputType::Type,
                    value: LineOutputValue::MetadataLineOutputValue(
                        MetadataLineOutputValue {
                            tokens: vec![
                                MetadataLineOutputValueToken {
                                    name: "id".to_owned(),
                                    value: "Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the ID starts with \"http://\" or \"https://\", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the client with the HTTP URL in the original_path and \"#url#\" as the conversion string. Clients should generate the file by downloading it to the specified location".to_owned(),
                                },
                            ],
                        },
                    ),
                },
                LineOutput {
                    type_: LineOutputType::Type,
                    value: LineOutputValue::MetadataLineOutputValue(
                        MetadataLineOutputValue {
                            tokens: vec![
                                MetadataLineOutputValueToken {
                                    name: "unique_id".to_owned(),
                                    value: "Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time".to_owned(),
                                },
                            ],
                        },
                    ),
                },
                LineOutput {
                    type_: LineOutputType::Type,
                    value: LineOutputValue::MetadataLineOutputValue(
                        MetadataLineOutputValue {
                            tokens: vec![
                                MetadataLineOutputValueToken {
                                    name: "is_uploading_active".to_owned(),
                                    value: "True, if the file is currently being uploaded (or a remote copy is being generated by some other means)".to_owned(),
                                },
                            ],
                        },
                    ),
                },
                LineOutput {
                    type_: LineOutputType::Type,
                    value: LineOutputValue::MetadataLineOutputValue(
                        MetadataLineOutputValue {
                            tokens: vec![
                                MetadataLineOutputValueToken {
                                    name: "is_uploading_completed".to_owned(),
                                    value: "True, if a remote copy is fully available".to_owned(),
                                },
                            ],
                        },
                    ),
                },
                LineOutput {
                    type_: LineOutputType::Type,
                    value: LineOutputValue::MetadataLineOutputValue(
                      MetadataLineOutputValue {
                          tokens: vec![
                              MetadataLineOutputValueToken {
                                  name: "uploaded_size".to_owned(),
                                  value: "Size of the remote available part of the file; 0 if unknown".to_owned(),
                              },
                          ],
                      },
                    ),
                },
            ],
        ))
    );
}

fn parse_field(s: &str) -> IResult<&str, NormalLineOutputValueField> {
    let (input, _) = is_a(SPACE)(s)?;
    // TODO: Find a more elegant way.
    if let Ok((input, _)) = tag::<_, _, (_, _)>("=")(input) {
        return Err(nom::Err::Error((input, ErrorKind::Complete)));
    }
    let (input, name) = is_not(":")(input)?;
    let (input, _) = tag(":")(input)?;
    let (input, type_) = is_not(SPACE)(input)?;
    Ok((
        input,
        NormalLineOutputValueField {
            name: name.to_owned(),
            type_: type_.to_owned(),
        },
    ))
}

fn parse_normal_line(input: (&str, LineOutputType)) -> IResult<(&str, LineOutputType), LineOutput> {
    let (input, type_) = input;
    let input = input.trim_start();
    let (input, type_id) = is_not(SPACE)(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, fields) =
        many0(parse_field)(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, _) = is_a(SPACE)(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, _) = tag("=")(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, _) = is_a(SPACE)(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, type_name) = is_not(";")(input).map_err(map_err_line_output_type(type_.clone()))?;
    let (input, _) = is_a(";")(input).map_err(map_err_line_output_type(type_.clone()))?;
    Ok((
        (input, type_.clone()),
        LineOutput {
            type_,
            value: LineOutputValue::NormalLineOutputValue(NormalLineOutputValue {
                id: type_id.to_owned(),
                name: type_name.to_owned(),
                fields,
            }),
        },
    ))
}

#[test]
fn test_parse_normal_line() {
    let res = many1(parse_normal_line)((r"
tdlibParameters use_test_dc:Bool database_directory:string files_directory:string use_file_database:Bool use_chat_info_database:Bool use_message_database:Bool use_secret_chats:Bool api_id:int32 api_hash:string system_language_code:string device_model:string system_version:string application_version:string enable_storage_optimizer:Bool ignore_file_names:Bool = TdlibParameters;".trim_start(), LineOutputType::Type));
    assert_eq!(
        res,
        Ok((
            ("", LineOutputType::Type),
            vec![LineOutput {
                type_: LineOutputType::Type,
                value: LineOutputValue::NormalLineOutputValue(NormalLineOutputValue {
                    id: "tdlibParameters".to_owned(),
                    fields: vec![
                        NormalLineOutputValueField {
                            name: "use_test_dc".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "database_directory".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "files_directory".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "use_file_database".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "use_chat_info_database".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "use_message_database".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "use_secret_chats".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "api_id".to_owned(),
                            type_: "int32".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "api_hash".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "system_language_code".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "device_model".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "system_version".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "application_version".to_owned(),
                            type_: "string".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "enable_storage_optimizer".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                        NormalLineOutputValueField {
                            name: "ignore_file_names".to_owned(),
                            type_: "Bool".to_owned(),
                        },
                    ],
                    name: "TdlibParameters".to_owned(),
                })
            }],
        ))
    );
}

fn parse_line(input: (&str, LineOutputType)) -> IResult<(&str, LineOutputType), LineOutput> {
    let (input, type_) = input;
    let input = input.trim_start();
    let (input, type_) = if input.starts_with("---functions---") {
        let (input, _) = tag::<_, _, (_, _)>("---functions---")(input).unwrap();
        (input.trim_start(), LineOutputType::Function)
    } else {
        (input, type_)
    };
    let is_metadata_line = input.starts_with("//");
    let (input, output) = if is_metadata_line {
        parse_metadata_line((input, type_))?
    } else {
        parse_normal_line((input, type_))?
    };
    Ok((input, output))
}

pub(crate) fn parse_lines(input: &str) -> IResult<&str, Vec<LineOutput>> {
    match many1(parse_line)((input, LineOutputType::Type)) {
        Ok(((input, _), output)) => Ok((input, output)),
        Err(nom::Err::Error(((input, _), output))) => Err(nom::Err::Error((input, output))),
        _ => unreachable!(),
    }
}
